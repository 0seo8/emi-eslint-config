#!/usr/bin/env node
import{parse as sr}from"tsconfck";import Bt from"string-dedent";import Ut from"meow";var Ue=Ut(`
Usage
  $ nanobundle <command> [options]

Available Commands
  build    Build once and exit
  clean    Remove outputs

Options
  --version            Display current version

  --cwd                Use an alternative working directory

  --clean              Clean outputs before build

  --tsconfig           Specify the path to a custom tsconfig.json

  --import-maps        Specify import map file path (default: package.json)

  --root-dir           Specify the path to resolve source entry (default: ./src)
                       This also can be configured by tsconfig.json

  --out-dir            Specify the path to resolve source entry (default: ./lib)
                       This also can be configured by tsconfig.json

  --platform           Specify bundle target platform (default: "netural")
                       One of "netural", "browser", "node" is allowed

  --standalone         Embed external dependencies into the bundle (default: false)

  --external           Specify external dependencies to exclude from the bundle

  --jsx                Specify JSX mode. One of "transform", "preserve", "automatic" is allowed
                       This also can be configured by tsconfig.json

  --jsx-factory        Specify JSX factory (default: "React.createElement")
                       This also can be configured by tsconfig.json

  --jsx-fragment       Specify JSX <Fragment> factory (default: "Fragment")
                       This also can be configured by tsconfig.json

  --jsx-import-source  Specify JSX import source (default: "react")
                       This also can be configured by tsconfig.json

  --no-sourcemap       Disable source map generation

  --no-legal-comments  Disable legal comments generation

  --no-bundle          Disable ESBuild bundle and other files build

  --no-dts             Disable TypeScript .d.ts build

  --verbose            Set to report build result more verbosely

  --help               Display this message
`,{importMeta:import.meta,flags:{cwd:{type:"string",default:process.cwd()},clean:{type:"boolean",default:!1},rootDir:{type:"string"},outDir:{type:"string"},tsconfig:{type:"string",default:"tsconfig.json"},importMaps:{type:"string",default:"package.json"},external:{type:"string",isMultiple:!0,default:[]},platform:{type:"string"},standalone:{type:"boolean",default:!1},sourcemap:{type:"boolean",default:!0},legalComments:{type:"boolean",default:!0},bundle:{type:"boolean",default:!0},dts:{type:"boolean",default:!0},jsx:{type:"string"},jsxFactory:{type:"string"},jsxFragment:{type:"string"},jsxImportSource:{type:"string"},verbose:{type:"boolean",default:!1}}});import{formatWithOptions as ne}from"node:util";import me from"kleur";import{formatWithOptions as He}from"node:util";import H from"kleur";var{FORCE_COLOR:qe,NODE_DISABLE_COLORS:Dt,NO_COLOR:Nt,TERM:St}=process.env,Rt=process.stdout.isTTY,ee=!Dt&&Nt==null&&St!=="dumb"&&(qe!=null&&qe!=="0"||Rt);function oe(e,t){let s="  ".repeat(t);return e.split(`
`).map(r=>`${s}${r}`).join(`
`)}function De(e,...t){return He({colors:ee},e,...t)}function ue(e){return H.underline().cyan(e)}function E(e){return H.underline().cyan(e)}function te(e){return e==null?H.bold().green(`${e}`):typeof e=="string"?H.green(`'${e}'`):typeof e!="object"?H.green(`${e}`):se(e)}function y(e){return H.bold().blue(`"${e}"`)}function se(e){let t=He({colors:ee},"%o",e);return H.white(t)}function Y(e){return H.bold().blue(`\`${e}\``)}function xe(e){return H.bold().cyan(e)}var B=class extends Error{},de=class extends B{};var ie=class{#r;#e;color=ee;level="debug";constructor(t,o=0){this.#r=o,this.#e=t}#t(t){return oe(t,this.#r)}debug(t,...o){if(this.level!=="debug")return;let s=ne({colors:this.color},t,...o),r=this.#t(s);this.#e.debug(me.gray(`[debug] ${r}`))}info(t,...o){let s=ne({colors:this.color},t,...o),r=this.#t(s);this.#e.info(me.white(`[info] ${r}`))}warn(t,...o){let s=ne({colors:this.color},t,...o),r=this.#t(s);this.#e.warn(me.yellow(`[warn] ${r}`))}error(t,...o){let s=ne({colors:this.color},t,...o),r=this.#t(s);this.#e.error(me.red(`[error] ${r}`))}captureException(t){let o;t instanceof B&&t.message?o=t.message:t instanceof Error?o=ne({colors:this.color},t.stack):o=ne({colors:this.color},"%s",t);let s=this.#t(o);this.#e.error(me.bold().red(`${s}`))}createChildReporter(){let t=new ie(this.#e,this.#r+1);return t.color=this.color,t}};import It from"browserslist";var Ke={chrome:"chrome",firefox:"firefox",safari:"safari",edge:"edge",node:"node",ios_saf:"ios",android:"chrome",and_chr:"chrome",and_ff:"firefox",deno:"chrome"},Mt=new Set(Object.keys(Ke));function _t(e){return Mt.has(e)}async function Qe(e){let t=It(e.query,{path:e.basePath}),o=new Map;for(let s of t){let[r,x]=s.split(" ");if(!_t(r))continue;let l=Ke[r],n=+x.split("-")[0];if(r==="android")if(n>4.4)l="chrome",n=96;else continue;let u=o.get(l);(!u||u>n)&&o.set(l,n)}return Array.from(o.entries()).map(s=>s.join(""))}import*as Ze from"node:path";import*as et from"node:fs/promises";var tt=async({basePath:e})=>{let t=Ze.resolve(e,"package.json"),{publishConfig:o,...s}=await et.readFile(t,"utf-8").then(JSON.parse);return{...s,...o}};import*as ae from"node:path";import Pt from"string-dedent";import*as rt from"semver";var fe=class extends B{name="NanobundleConfigError"};function ot({flags:e,manifest:t,targets:o,reporter:s,tsconfig:r,tsconfigPath:x}){var g,v,N,R,D,k,C,_,h,O,a,q,f;let l=ae.resolve(e.cwd),n=(...W)=>ae.resolve(l,...W),u=(W,re=!1)=>{let Ee=ae.relative(l,W);return re?`./${Ee}`:Ee},c=e.bundle,p=e.verbose,i=e.legalComments,b=e.standalone,j=x,U=ae.resolve(l,e.importMaps),T=e.external,M=[...t.dependencies?Object.keys(t.dependencies):[],...t.peerDependencies?Object.keys(t.peerDependencies):[],...T],w=e.rootDir||((g=r==null?void 0:r.compilerOptions)==null?void 0:g.rootDir)||"src",$=e.outDir||((v=r==null?void 0:r.compilerOptions)==null?void 0:v.outDir)||"lib",X=t.type==="module"?"esmodule":"commonjs",I=!0;((N=r==null?void 0:r.compilerOptions)==null?void 0:N.sourceMap)!=null&&(I=r.compilerOptions.sourceMap),e.sourcemap===!1&&(I=!1);let m="neutral";["node","deno","web"].includes(e.platform||"")?m=e.platform:(R=t.engines)!=null&&R.node&&(m="node");let F=[...o];if((D=t.engines)!=null&&D.node){let W=rt.minVersion(t.engines.node);W&&(F=[...F,`node${W.major}`])}m==="node"&&!F.some(W=>W.startsWith("node"))&&(F=[...F,"node14"]),m==="node"&&(F=F.filter(W=>W.startsWith("node"))),m==="browser"&&(F=F.filter(W=>!W.startsWith("node")));let le=!1;if(e.dts&&r&&(le=((k=r.compilerOptions)==null?void 0:k.declaration)!==!1),!le&&w===$)throw new fe(Pt`
      ${y("rootDir")} (${E(w)}) and ${y("outDir")} (${E($)}) are conflict!

      Please specify different directory for one of them.
    `);let z;((C=r==null?void 0:r.compilerOptions)==null?void 0:C.jsx)==="preserve"&&(z="preserve"),["react","react-native"].includes((_=r==null?void 0:r.compilerOptions)==null?void 0:_.jsx)&&(z="transform"),["react-jsx","react-jsxdev"].includes((h=r==null?void 0:r.compilerOptions)==null?void 0:h.jsx)&&(z="automatic"),e.jsx==="preserve"&&(z="preserve"),e.jsx==="transform"&&(z="transform"),e.jsx==="automatic"&&(z="automatic");let pe=!1;!e.jsx&&((O=r==null?void 0:r.compilerOptions)==null?void 0:O.jsx)==="react-jsxdev"&&(pe=!0);let L=e.jsxFactory||((a=r==null?void 0:r.compilerOptions)==null?void 0:a.jsxFactory)||"React.createElement",Ge=e.jsxFragment||((q=r==null?void 0:r.compilerOptions)==null?void 0:q.jsxFragmentFactory)||"Fragment",d=e.jsxImportSource||((f=r==null?void 0:r.compilerOptions)==null?void 0:f.jsxImportSource)||"react";return{cwd:l,verbose:p,module:X,platform:m,sourcemap:I,legalComments:i,bundle:c,declaration:le,jsx:z,jsxDev:pe,jsxFactory:L,jsxFragment:Ge,jsxImportSource:d,standalone:b,rootDir:w,outDir:$,tsconfigPath:j,importMapsPath:U,externalDependencies:M,forceExternalDependencies:T,manifest:t,targets:F,reporter:s,resolvePath:n,resolveRelativePath:u}}import*as Q from"node:path";import P from"string-dedent";import st from"kleur";var nt=({context:e,reporter:t})=>{let{cwd:r,rootDir:x,outDir:l,sourcemap:n,manifest:u,tsconfigPath:c,jsx:p,platform:i,module:b}=e,j={commonjs:"commonjs",esmodule:"esmodule",css:void 0,dts:void 0,file:void 0}[b],U=e.resolvePath(x),T=e.resolvePath(l),M=p!=null,w=c!=null,$=!(w&&U===T),X=e.jsx==="preserve",I=new Map;function m(d){var ze;let{key:g,parentKey:v,sourcemap:N,entryPath:R,platform:D,module:k,mode:C,preferredModule:_,customConditions:h}=d;if(!R.startsWith("./"))throw new J(A.INVALID_PATH_KEY(g));if(R.includes("*"))throw new J(A.SUBPATH_PATTERN(R));if(k==="dts"&&!/\.d\.(c|m)?ts$/.test(R))throw new J(A.INVALID_DTS_FORMAT());let O=I.get(R);if(O){if(O.key.startsWith("exports")&&!g.startsWith("exports")){(O.platform!==D||O.module!==k)&&t.warn(A.PRECEDENSE_ENTRY(O,d));return}if(O.platform!==D||O.module!==k){let S="";throw(O.key==="main"&&g==="module"||O.key==="module"&&g==="main")&&(S=P`
            Did you forgot to set ${y("type")} to ${te("module")} for ESM-first approach?
          `),O.module===k&&O.platform!==D&&(S=P`
            Did you forget to specify the Node.js version in the ${y("engines")} field?
            Or you may not need to specify ${y("require")} or ${y("node")} entries.
          `),new J(A.CONFLICT_ENTRY(O,d,S))}return}let a=new Set,q=e.resolvePath(R),f=q.replace(T,U),W=/\.min(?<ext>\.(m|c)?jsx?)$/,re=f.match(W),Ee=!!re,Ye=(ze=re==null?void 0:re.groups)==null?void 0:ze.ext;if(Ye&&(f=f.replace(W,Ye)),!/jsx?$/.test(f))switch(k){case"commonjs":{w&&a.add(`${f}.cts`),$&&a.add(`${f}.cjs`),M&&w&&a.add(`${f}.tsx`),w&&a.add(`${f}.ts`),M&&$&&a.add(`${f}.jsx`),$&&a.add(`${f}.js`);break}case"esmodule":{w&&a.add(`${f}.mts`),$&&a.add(`${f}.mjs`),M&&w&&a.add(`${f}.tsx`),w&&a.add(`${f}.ts`),M&&$&&a.add(`${f}.jsx`),$&&a.add(`${f}.js`);break}}switch(k){case"commonjs":{if(w&&a.add(f.replace(/\.c?jsx?$/,".cts")),$&&a.add(f.replace(/\.c?jsx?$/,".cjs")),M&&w&&a.add(f.replace(/\.c?jsx?$/,".tsx")),w&&a.add(f.replace(/\.c?jsx?$/,".ts")),M&&$&&a.add(f.replace(/\.c?jsx?$/,".jsx")),$&&a.add(f.replace(/\.c?jsx?$/,".js")),v){let S=f.replace("."+v,"");w&&a.add(S.replace(/\.c?jsx?$/,".cts")),$&&a.add(S.replace(/\.c?jsx?$/,".cjs")),M&&w&&a.add(S.replace(/\.c?jsx?$/,".tsx")),w&&a.add(S.replace(/\.c?jsx?$/,".ts")),M&&$&&a.add(S.replace(/\.c?jsx?$/,".jsx")),$&&a.add(S.replace(/\.c?jsx?$/,".js"))}$&&a.add(f);break}case"esmodule":{if(w&&a.add(f.replace(/\.m?jsx?$/,".mts")),$&&a.add(f.replace(/\.m?jsx?$/,".mjs")),M&&w&&a.add(f.replace(/\.m?jsx?$/,".tsx")),w&&a.add(f.replace(/\.m?jsx?$/,".ts")),M&&$&&a.add(f.replace(/\.m?jsx?$/,".jsx")),$&&a.add(f.replace(/\.m?jsx?$/,".js")),v){let S=f.replace("."+v,"");w&&a.add(S.replace(/\.m?jsx?$/,".mts")),$&&a.add(S.replace(/\.m?jsx?$/,".mjs")),M&&w&&a.add(S.replace(/\.m?jsx?$/,".tsx")),w&&a.add(S.replace(/\.m?jsx?$/,".ts")),M&&$&&a.add(S.replace(/\.m?jsx?$/,".jsx")),$&&a.add(S.replace(/\.m?jsx?$/,".js"))}$&&a.add(f);break}case"css":{a.add(f);break}case"dts":{let S=/\.d\.(c|m)ts$/,K,Be=".ts";if(!w)break;_==="commonjs"?(K=/\.d\.(c?)ts$/,Be=".cts"):_==="esmodule"&&(K=/\.d\.(m?)ts$/,Be=".mts"),K!=null&&K.test(f)?a.add(f.replace(K,Be)):S.test(f)&&a.add(f.replace(S,".$1ts")),M&&a.add(f.replace(/\.d\.(m|c)?ts$/,".tsx")),a.add(f.replace(/\.d\.(m|c)?ts$/,".ts"));break}case"file":{Q.relative(r,Q.dirname(q))?a.add(f):a.add(q);break}}let Xe=[...a];M&&Xe.sort((S,K)=>S.endsWith("x")&&K.endsWith("x")?0:S.endsWith("x")?-1:1),I.set(R,{key:g,entryPath:R,mode:C,minify:Ee,sourcemap:N,platform:D,module:k,sourceFile:Xe,outputFile:q,customConditions:h})}function F({key:d,entryPath:g}){switch(Q.extname(g)){case".cjs":{m({key:d,sourcemap:n,platform:i,mode:void 0,module:"commonjs",preferredModule:"commonjs",entryPath:g,customConditions:[]});break}case".mjs":{m({key:d,sourcemap:n,platform:i,mode:void 0,module:"esmodule",preferredModule:"esmodule",entryPath:g,customConditions:[]});break}case".node":{m({key:d,sourcemap:n,platform:"node",mode:void 0,module:"file",entryPath:g,customConditions:[]});break}case".json":{m({key:d,sourcemap:n,platform:i,mode:void 0,module:"file",entryPath:g,customConditions:[]});break}case".jsx":X||t.warn(A.NO_NEED_JSX(g));default:{m({key:d,sourcemap:n,platform:i,mode:void 0,module:b,entryPath:g,customConditions:[]});break}}}function le({key:d,entryPath:g}){if(/\.m?jsx?$/.test(g))m({key:d,sourcemap:n,platform:i,mode:void 0,module:"esmodule",preferredModule:"esmodule",entryPath:g,customConditions:[]});else throw new J(A.INVALID_MODULE_EXTENSION())}function z({key:d,entryPath:g}){if(/\.d\.(m|c)?ts$/.test(g))m({key:d,sourcemap:n,platform:i,mode:void 0,module:"dts",preferredModule:j,entryPath:g,customConditions:[]});else throw new J(A.INVALID_TYPES_EXTENSION())}function pe({key:d,entryPath:g}){switch(Q.extname(g)){case".js":{m({key:d,sourcemap:!1,platform:"node",mode:void 0,module:b,preferredModule:j,entryPath:g,customConditions:[]});break}case".cjs":{m({key:d,sourcemap:!1,platform:"node",mode:void 0,module:"commonjs",preferredModule:j,entryPath:g,customConditions:[]});break}case".mjs":{m({key:d,sourcemap:!1,platform:"node",mode:void 0,module:"esmodule",preferredModule:j,entryPath:g,customConditions:[]});break}default:throw new J(A.INVALID_BIN_EXTENSION())}}function L({key:d,parentKey:g,platform:v,mode:N,module:R,preferredModule:D,entryPath:k,customConditions:C}){if(typeof k=="string"){if(g==="types"){m({key:d,parentKey:g,sourcemap:n,platform:v,mode:N,module:"dts",preferredModule:D,entryPath:k,customConditions:C});return}switch(Q.extname(k)){case".cjs":{m({key:d,parentKey:g,sourcemap:n,platform:v,mode:N,module:"commonjs",preferredModule:"commonjs",entryPath:k,customConditions:C});break}case".mjs":{m({key:d,parentKey:g,sourcemap:n,platform:v,mode:N,module:"esmodule",preferredModule:"esmodule",entryPath:k,customConditions:C});break}case".node":{m({key:d,parentKey:g,sourcemap:n,platform:"node",mode:N,module:"file",preferredModule:D,entryPath:k,customConditions:C});break}case".json":{m({key:d,parentKey:g,sourcemap:n,platform:v,mode:N,module:"file",preferredModule:D,entryPath:k,customConditions:C});break}case".css":{m({key:d,parentKey:g,sourcemap:n,platform:v,mode:N,module:"css",preferredModule:D,entryPath:k,customConditions:C});break}case".jsx":X||t.warn(A.NO_NEED_JSX(k));default:{m({key:d,parentKey:g,sourcemap:n,platform:v,mode:N,module:R,preferredModule:D,entryPath:k,customConditions:C});break}}}else if(typeof k=="object"){if(g==="types")throw new J(A.INVALID_DTS_FORMAT());let _=Object.entries(k);if(typeof k.types<"u"){if(_.findIndex(O=>O[0]==="types")!==0)throw new J(A.INVALID_DTS_ORDER())}else{let h=_.find(([a,q])=>typeof q=="string"&&!a.startsWith("."));if(w&&h!==void 0)if(typeof k.default=="string")_=[["types$implicit",ke(k.default)],..._];else{if(typeof k.require=="string"&&typeof k.import=="string")throw new J(A.UNDETEMINED_DTS_SOURCE(d,k.require,k.import));typeof k.require=="string"?_=[["types$implicit",ke(k.require)],..._]:typeof k.import=="string"?_=[["types$implicit",ke(k.import)],..._]:D?_=[["types$implicit",ke(h[1])],..._]:t.warn(A.TYPES_MAY_NOT_BE_RESOLVED(d))}}for(let[h,O]of _)switch(h){case"import":{L({key:`${d}.${h}`,parentKey:h,platform:v,mode:N,module:"esmodule",preferredModule:"esmodule",entryPath:O,customConditions:C});break}case"require":{L({key:`${d}.${h}`,parentKey:h,platform:v,mode:N,module:"commonjs",preferredModule:"commonjs",entryPath:O,customConditions:C});break}case"types":{L({key:`${d}.${h}`,parentKey:h,platform:v,mode:N,module:"dts",preferredModule:void 0,entryPath:O,customConditions:C});break}case"types$implicit":{L({key:`${d}.types`,parentKey:h,platform:v,mode:N,module:"dts",preferredModule:D,entryPath:O,customConditions:C});break}case"node":{L({key:`${d}.${h}`,parentKey:h,platform:"node",mode:N,module:R,preferredModule:D,entryPath:O,customConditions:C});break}case"deno":{L({key:`${d}.${h}`,parentKey:h,platform:"deno",mode:N,module:R,preferredModule:D,entryPath:O,customConditions:C});break}case"browser":{L({key:`${d}.${h}`,parentKey:h,platform:"browser",mode:N,module:R,preferredModule:D,entryPath:O,customConditions:C});break}case"development":{L({key:`${d}.${h}`,parentKey:h,platform:v,mode:"development",module:R,preferredModule:D,entryPath:O,customConditions:C});break}case"production":{L({key:`${d}.${h}`,parentKey:h,platform:v,mode:"production",module:R,preferredModule:D,entryPath:O,customConditions:C});break}case"default":{L({key:`${d}.${h}`,parentKey:h,platform:v,mode:N,module:R,preferredModule:D,entryPath:O,customConditions:C});break}case".":{L({key:`${d}["${h}"]`,parentKey:h,platform:v,mode:N,module:R,preferredModule:D,entryPath:O,customConditions:C});break}default:{h.startsWith("./")?L({key:`${d}["${h}"]`,parentKey:h,platform:v,mode:N,module:R,preferredModule:D,entryPath:O,customConditions:C}):(t.warn(A.CUSTOM_CONDITION(h)),L({key:`${d}.${h}`,parentKey:h,platform:v,mode:N,module:R,preferredModule:D,entryPath:O,customConditions:[...new Set([...C,h])]}));break}}}}if(u.exports?L({key:"exports",parentKey:"exports",platform:i,mode:void 0,module:b,preferredModule:j,entryPath:u.exports,customConditions:[]}):(u.main||u.module)&&t.warn(A.RECOMMEND_EXPORTS()),typeof u.main=="string"&&F({key:"main",entryPath:u.main}),typeof u.module=="string"&&(le({key:"module",entryPath:u.module}),t.warn(A.MODULE_NOT_RECOMMENDED())),typeof u.types=="string"&&z({key:"types",entryPath:u.types}),typeof u.bin=="string"&&pe({key:"bin",entryPath:u.bin}),typeof u.bin=="object")for(let[d,g]of Object.entries(u.bin))pe({key:`bin["${d}"]`,entryPath:g});return[...I.values()]};function ke(e){return e.replace(/(\.min)?\.(m|c)?jsx?$/,".d.$2ts")}var J=class extends B{},A={INVALID_MAIN_EXTENSION:()=>P`
    Only ${E(".js")}, ${E(".cjs")}, ${E(".mjs")}, ${E(".json")}, or ${E(".node")} allowed for ${y("main")} entry.

  `,INVALID_MODULE_EXTENSION:()=>P`
    Only ${E(".js")} or ${E(".mjs")} allowed for ${y("module")} entry.

  `,INVALID_TYPES_EXTENSION:()=>P`
    Only ${E(".d.ts")} or ${E(".d.cts")} or ${E(".d.mts")} allowed for ${y("types")} entry.

  `,INVALID_BIN_EXTENSION:()=>P`
    Only JavaScript files are allowed for ${E("bin")} entry.

  `,INVALID_PATH_KEY:e=>P`
    Invalid entry path ${E(e)}, entry path should starts with ${te("./")}.

  `,INVALID_DTS_FORMAT:()=>P`
    ${y("types")} entry must be .d.ts file and cannot be nested!

  `,INVALID_DTS_ORDER:()=>P`
    ${y("types")} entry must occur first in conditional exports for correct type resolution.

  `,UNDETEMINED_DTS_SOURCE:(e,t,o)=>P`
    ${y("types")} entry doesn't set properly for ${y(e)}:

        "require": "${t}",
        "import": "${o}"

    Solution 1. Explicitly set ${y("types")} entry
      
      For example like this

      + "types": "${t.replace(/\.(m|c)?js$/,".d.ts")}",
        "require": "${t}",
        "import": "${o}"

      Or like this

        "require": {
      +   "types": "${t.replace(/\.(m|c)?js$/,".d.$1ts")}",
          "default": "${t}"
        },
        "import": {
      +   "types": "${o.replace(/\.(m|c)?js$/,".d.$1ts")}",
          "default": "${o}"
        }

    Solution 2. Add ${y("default")} entry

        "require": "${t}",
        "import": "${o}",
      + "default": "/path/to/entry.js"

  `,SUBPATH_PATTERN:e=>P`
    Subpath pattern (${E(e)}) is not supported yet.

  `,CONFLICT_ENTRY:(e,t,o)=>De(P`
      Conflict found for ${E(e.entryPath)}

          %s
          %s

        vs

          %s ${st.bold("(conflited)")}
          %s

    `,y(e.key),se({module:e.module,platform:e.platform}),y(t.key),se({module:t.module,platform:t.platform}))+o?`Hint: ${o}

`:"",PRECEDENSE_ENTRY:(e,t)=>De(P`
      Entry ${y(t.key)} will be ignored since

          %s
          %s

        precedense over

          %s ${st.bold("(ignored)")}
          %s

    `,y(e.key),se({module:e.module,platform:e.platform}),y(t.key),se({module:t.module,platform:t.platform})),RECOMMEND_EXPORTS:()=>P`
    Using ${y("exports")} field is highly recommended.

      See ${ue("https://nodejs.org/api/packages.html")} for more detail.

  `,MODULE_NOT_RECOMMENDED:()=>P`
    ${y("module")} field is not standard and may works in only legacy bundlers. Consider using ${y("exports")} instead.
      See ${ue("https://nodejs.org/api/packages.html")} for more detail.

  `,TYPES_MAY_NOT_BE_RESOLVED:e=>P`
    ${y(e)} entry might not be resolved correctly in ${y("moduleResolution")}: ${te("Node16")}.

    Consider to specify ${y("types")} entry for it.

  `,NO_NEED_JSX:e=>P`
    ${E(e)} doesn't have to be \`.jsx\` unless you are using ${y("preserve")} mode.
  `,CUSTOM_CONDITION:e=>P`
    Custom condition ${y(e)} may has no effects.
  `};import er from"string-dedent";import{performance as tr}from"node:perf_hooks";import{interpret as rr}from"xstate";import{performance as wt}from"node:perf_hooks";import Qt from"string-dedent";import{assign as Z,createMachine as Zt}from"xstate";function Ne(e){return e.module==="esmodule"||e.module==="commonjs"||e.module==="css"}function it(e){return e.module==="dts"}function at(e){return e.module==="file"}function At(e){let t={mode:e.mode,module:e.module,minify:e.minify,platform:e.platform,sourcemap:e.sourcemap,customConditions:[...e.customConditions].sort()};return JSON.stringify(t)}function lt(e){return JSON.parse(e)}function Lt(e){return{mode:e.mode,module:e.module,minify:e.minify,platform:e.platform,sourcemap:e.sourcemap,customConditions:e.customConditions}}function pt(e){let t={};for(let o of e){let s=Lt(o),r=At(s);t[r]?t[r].push(o):t[r]=[o]}return t}import*as yt from"esbuild";import Vt from"string-dedent";import*as Oe from"node:fs";function Se(e){return Oe.promises.access(e,Oe.constants.F_OK).then(()=>!0).catch(()=>!1)}async function $e(e){let t=null;for(let o of e)if(await Se(o)){t=o;break}return t}function ce(e){return/^(\.{0,2}\/).*/.test(e)}import*as ye from"node:path";import*as ut from"node:fs/promises";var Ie=/^(?<dirname>.+\/)(?<filename>(?<base>[^\/\.]+?)(?<ext>\..+)?)$/;async function dt(e){let{imports:t={}}=await ut.readFile(e.importMapsPath,"utf-8").then(JSON.parse);return{imports:t}}async function Me({context:e,importMaps:t,rootKey:o}){for(let[s,r]of Object.entries(t.imports))if(typeof r=="object")await Me({context:e,importMaps:{imports:r},rootKey:o||s});else{if(!(o||s).startsWith("#")&&(s.includes("*")||r.includes("*")))throw new de("Subpath pattern (*) imports is supported only for Node.js-style imports like #pattern/*.js");if(!ce(r))continue;let x=ye.resolve(ye.dirname(e.importMapsPath),r.includes("*")?ye.dirname(r):r);if(!await Se(x))throw new de(`${E(x)} doesn't exist`)}return t}function mt(e,t){function o(u,c,p,i,b,j){if(typeof c=="string")return c;for(let[U,T]of Object.entries(c)){if(U==="node"&&b==="node")return typeof T=="string"?T:o(u,T,p,i,"node",j);if(U==="browser"&&b==="browser")return typeof T=="string"?T:o(u,c,p,i,"browser",j);if(U==="require"&&i==="commonjs")return typeof T=="string"?T:o(u,c,p,"commonjs",b,j);if(U==="import"&&i==="esmodule")return typeof T=="string"?T:o(u,c,p,"esmodule",b,j);if(U==="development"&&p==="development")return typeof T=="string"?T:o(u,c,"development",i,b,j);if(U==="production"&&p==="production")return typeof T=="string"?T:o(u,c,"production",i,b,j);if(j.includes(U)||U==="default")return typeof T=="string"?T:o(u,c,p,i,b,j)}return u}let{mode:s,module:r,platform:x,customConditions:l}=t,n={imports:{}};for(let[u,c]of Object.entries(e.imports))n.imports[u]=o(u,c,s,r,x,l);return n}function ft(e,t){var r,x,l,n,u,c,p,i,b,j,U,T,M,w;if(e.imports[t])return e.imports[t];let o=Object.entries(e.imports).sort(([$,X])=>$.includes("*")?-1:0),s={};for(let[$,X]of o){if(t.startsWith($))return t.replace($,X);let I=s[$]||$.match(Ie),m=s[X]||X.match(Ie),F=s[t]||t.match(Ie);if(((r=I==null?void 0:I.groups)==null?void 0:r.dirname)===((x=F==null?void 0:F.groups)==null?void 0:x.dirname)){if(((l=I==null?void 0:I.groups)==null?void 0:l.filename)==="*")return(((n=m==null?void 0:m.groups)==null?void 0:n.dirname)||"")+(((u=m==null?void 0:m.groups)==null?void 0:u.base)==="*"?((c=F==null?void 0:F.groups)==null?void 0:c.filename)+(((p=m==null?void 0:m.groups)==null?void 0:p.ext)||""):((i=m==null?void 0:m.groups)==null?void 0:i.filename)||"");if(((b=I==null?void 0:I.groups)==null?void 0:b.base)==="*"&&((j=I==null?void 0:I.groups)==null?void 0:j.ext)===((U=F==null?void 0:F.groups)==null?void 0:U.ext))return(((T=m==null?void 0:m.groups)==null?void 0:T.dirname)||"")+(((M=F==null?void 0:F.groups)==null?void 0:M.base)||"")+(((w=m==null?void 0:m.groups)==null?void 0:w.ext)||"")}}return t}import*as je from"node:path";function ct({context:e,context:{reporter:t,standalone:o,externalDependencies:s,forceExternalDependencies:r},importMaps:x}){let l=(p,i)=>p===i||i.startsWith(p+"/"),n=p=>s.some(i=>p.startsWith(i))?!1:p.startsWith("node:")||Wt.some(i=>l(i,p)),u=p=>r.some(i=>l(i,p))?!1:o||!s.some(i=>l(i,p)),c=async p=>{let i=je.resolve(je.dirname(e.importMapsPath),p);return await $e([i.replace(/\.(c|m)?js$/,".tsx"),i.replace(/\.(c|m)?js$/,".ts"),i])||i};return{name:"nanobundle",setup(p){let i=!1;p.onResolve({filter:/.*/},async b=>{if(ce(b.path))return;let j=ft(x,b.path),U=!ce(j),T=n(j);return T&&(i=!0),!T&&u(j)?{}:{external:U,path:U?j:await c(j)}}),p.onEnd(()=>{o&&i&&t.warn("Not completely standalone bundle, while the code depends on some Node.js APIs.")})}}}var Wt=["assert","async_hooks","buffer","child_process","cluster","console","crypto","diagnostics_channel","dns","events","fs","http","http2","https","inspector","module","net","os","path","perf_hooks","process","readline","stream","string_decoder","timers","tls","trace_events","tty","dgram","url","util","v8","vm","wasi","worker_threads","zlib","querystring","_linklist","_stream_wrap","constants","domain","punycode","sys"];var Te=class extends B{esbuildErrors;constructor(t,o){super(t),this.esbuildErrors=o}};async function gt({context:e,bundleEntries:t}){if(!e.bundle)return e.reporter.debug("buildBundleTask skipped since bundle=false"),{outputFiles:[]};if(t.length>0)e.reporter.debug(`start buildBundleTask for ${t.length} entries`);else return e.reporter.debug("there are no js entries, skipped buildBundleTask"),{outputFiles:[]};let o=await dt(e),s=await Me({context:e,importMaps:o}),r=pt(t),x=[];for(let[p,i]of Object.entries(r)){let b=lt(p);e.reporter.debug("bundle options %o",b),x.push(Jt({context:e,options:b,bundleEntries:i,validImportMaps:s,plugins:[]}))}let l=await Promise.all(x),n=l.flatMap(p=>p.errors);if(n.length>0)throw new Te("Some errors occur while running esbuild",n);let u=l.flatMap(p=>p.warnings);if(u.length>0)for(let p of u)e.reporter.warn(p.text);return{outputFiles:l.flatMap(p=>p.outputFiles).map(p=>({path:p.path,content:p.contents}))}}async function Jt({context:e,plugins:t,validImportMaps:o,bundleEntries:s,options:r}){let x=[];for(let i of s){let b=await $e(i.sourceFile);if(!b)throw new Te(Vt`
        Source file doesn not exist.

          Expected one of
            - ${i.sourceFile.join(`
    - `)}

          But no matched files found.

        Please check your ${y("rootDir")} or ${y("outDir")} and try again.
        You can configure it in your ${E("tsconfig.json")}, or in CLI by ${Y("--root-dir")} and ${Y("--out-dir")} argument.

      `,[]);x.push({in:b,out:i.outputFile})}e.reporter.debug("esbuild entryPoints: %o",x);let l={bundle:!0,target:e.targets,sourcemap:r.sourcemap,legalComments:e.legalComments?"linked":"none",minify:r.minify,define:{"process.env.NANOBUNDLE_PACKAGE_NAME":JSON.stringify(e.manifest.name||"unknown"),"process.env.NANOBUNDLE_PACKAGE_VERSION":JSON.stringify(e.manifest.version||"0.0.0")}};if(r.module==="commonjs"||r.module==="esmodule"){l={...l,tsconfig:e.tsconfigPath,jsx:e.jsx,jsxDev:e.jsxDev,jsxFactory:e.jsxFactory,jsxFragment:e.jsxFragment,jsxImportSource:e.jsxImportSource,treeShaking:!0,keepNames:!0,format:r.module==="commonjs"?"cjs":"esm",conditions:r.customConditions},r.platform==="deno"?l.platform="neutral":l.platform=r.platform,r.mode&&(l.define={...l.define,"process.env.NODE_ENV":JSON.stringify(r.mode),"process.env.NANOBUNDLE_MODE":JSON.stringify(r.mode)});let i=mt(o,r),b=ct({context:e,importMaps:i});l.plugins=[b,...t]}e.reporter.debug("esbuild build options %o",l);let n=await Promise.all(x.map(i=>yt.build({...l,entryPoints:[i.in],outfile:i.out,write:!1}))),u=n.flatMap(i=>i.outputFiles.filter(b=>!(b.path.endsWith(".LEGAL.txt")&&b.contents.length===0)).map(b=>({...b,path:b.path}))),c=n.flatMap(i=>i.errors),p=n.flatMap(i=>i.warnings);return{errors:c,warnings:p,outputFiles:u}}import*as bt from"node:fs/promises";import Gt from"string-dedent";var _e=class extends B{reasons;constructor(t){super(),this.reasons=t}};async function ht({context:e,fileEntries:t}){if(!e.bundle)return e.reporter.debug("buildFileTask skipped since bundle=false"),{outputFiles:[]};if(t.length>0)e.reporter.debug(`start buildFileTask for ${t.length} entries`);else return e.reporter.debug("there are no file entries, skipped buildFileTask"),{outputFiles:[]};let o=[];for(let n of t){let u=n.sourceFile[0],c=n.outputFile;if(u===c){e.reporter.debug(Gt`
        noop for ${y(n.key)} because of source path and output path are the same.
          entry path: ${E(n.entryPath)}
      `);continue}o.push(Yt({sourceFile:u,outputFile:c}))}let s=await Promise.allSettled(o),r=s.filter(n=>n.status==="rejected");if(r.length)throw new _e(r.map(n=>n.reason));return{outputFiles:s.map(n=>n.value.outputFile)}}async function Yt({sourceFile:e,outputFile:t}){let o=await bt.readFile(e);return{outputFile:{sourcePath:e,path:t,content:o}}}import we from"string-dedent";import{parseNative as Xt}from"tsconfck";var Pe=class extends B{},Ae=class extends B{constructor(t,o,s){let r=we`
      [error] TypeScript compilation failed

      ${oe(ee?t.formatDiagnosticsWithColorAndContext(s,o):t.formatDiagnostics(s,o),1)}
    `;super(r)}};async function Et({context:e,typeEntries:t}){if(!e.declaration)return e.reporter.debug("buildTypeTask skipped since declaration=false"),{outputFiles:[]};if(!e.tsconfigPath)return e.reporter.debug("buildTypeTask skipped since no tsconfig.json provided"),{outputFiles:[]};if(t.length>0)e.reporter.debug(`start buildTypeTask for ${t.length} entries`);else return e.reporter.debug("there are no dts entries, skipped buildTypeTask"),{outputFiles:[]};let o;try{o=await import("typescript").then(c=>c.default)}catch{throw new Pe(we`
      Couldn't load TypeScript API

        Try ${Y("npm i -D typescript")} or ${Y("yarn add -D typescript")} and build again.

    `)}e.reporter.debug("loaded TypeScript compiler API version %s",o.version);let{result:s}=await Xt(e.tsconfigPath),r={...s.options,rootDir:e.rootDir,outDir:e.outDir,allowJs:!0,composite:!1,incremental:!1,skipLibCheck:!0,declaration:!0,emitDeclarationOnly:!0};r.noEmit&&e.reporter.warn(we`
      Ignored ${y("noEmit")} specified in your tsconfig.json

        You can disable emitting declaration via ${Y("--no-dts")} flag.

    `),r.noEmit=!1,r.moduleResolution===o.ModuleResolutionKind.Node16||r.moduleResolution===o.ModuleResolutionKind.NodeNext||e.reporter.warn(we`
      nanobundle recommends to use ${te("Node16")} or ${te("NodeNext")} for ${y("compilerOptions.moduleResolution")}

        See ${ue("https://www.typescriptlang.org/docs/handbook/esm-node.html")} for more detail.

    `),e.reporter.debug("loaded compilerOptions %o",r);let x=new Map,l=o.createCompilerHost(r);l.writeFile=(c,p)=>{e.reporter.debug(`ts program emitted file to ${E(c)}`),x.set(c,Buffer.from(p,"utf-8"))};let n=[];for(let c of t){let p=o.createProgram(c.sourceFile,r,l);e.reporter.debug("created ts program from %o",c.sourceFile);let i=p.emit(),b=zt(o.getPreEmitDiagnostics(p).concat(i.diagnostics)),j=[];for(let U of b)if(!qt.includes(U.code))switch(U.category){case o.DiagnosticCategory.Error:{j.push(U);break}default:{n.push(U);break}}if(j.length>0)throw new Ae(o,l,j)}return n.length>0&&e.reporter.warn(ee?o.formatDiagnosticsWithColorAndContext(n,l):o.formatDiagnostics(n,l)),{outputFiles:[...x.entries()].map(([c,p])=>({path:c,content:p}))}}function zt(e){let t=[],o=new Set,s=new Set;for(let r of e)r.file?s.has(r.file.fileName)||(s.add(r.file.fileName),t.push(r)):o.has(r.code)||(o.add(r.code),t.push(r));return t}var qt=[6053];import*as xt from"node:fs/promises";async function kt({context:e,binEntries:t}){let o=[];for(let s of t)o.push(xt.chmod(s.outputFile,"+x"));return await Promise.all(o),{}}import*as Le from"node:fs/promises";var We=class extends B{reasons;constructor(t){super(),this.reasons=t}};async function ve({context:e,outputFiles:t}){let o=e.resolvePath(e.outDir),s=e.resolveRelativePath(o);if(s!==""&&!s.startsWith(".."))return e.reporter.info(`\u{1F5D1}\uFE0F  ${E("./"+s)}`),await Le.rm(o,{recursive:!0,force:!0}),{};let r=[];for(let n of t){if(n.path===n.sourcePath){e.reporter.debug(`src=dest for ${n.path}, skipping`);continue}e.reporter.info(`\u{1F5D1}\uFE0F  ${E("./"+e.resolveRelativePath(n.path))}`),r.push(Le.rm(n.path,{force:!0}))}let l=(await Promise.allSettled(r)).filter(n=>n.status==="rejected");if(l.length)throw new We(l.map(n=>n.reason));return{}}import*as Fe from"node:fs/promises";import*as Ot from"node:path";var Ve=class extends B{reasons;constructor(t){super(),this.reasons=t}};async function $t({outputFiles:e}){let t=[];for(let r of e)t.push(Fe.mkdir(Ot.dirname(r.path),{recursive:!0}).then(()=>Fe.writeFile(r.path,r.content)));let s=(await Promise.allSettled(t)).filter(r=>r.status==="rejected");if(s.length)throw new Ve(s.map(r=>r.reason));return{outputFiles:e}}import*as Ce from"node:zlib";import{promisify as jt}from"node:util";import ge from"string-dedent";import Je from"pretty-bytes";var Ht=jt(Ce.gzip),Kt=jt(Ce.brotliCompress);async function Tt({context:e,bundleOutputs:t,fileOutputs:o,typeOutputs:s}){let r=t.filter(n=>!n.path.endsWith(".map")).filter(n=>!n.path.endsWith(".LEGAL.txt")),x=r.at(-1),l=r.length!==1;e.reporter.info(ge`
    ${l?"Bundles":"A bundle"} generated

  `);for(let n of r){let[u,c]=await Promise.all([Ht(n.content),Kt(n.content)]);e.reporter.info(ge`
      📦 ${E(e.resolveRelativePath(n.path,!0))}${e.verbose?`
`+oe(ge`
        Size      : ${Je(n.content.byteLength)}
        Size (gz) : ${Je(u.byteLength)}
        Size (br) : ${Je(c.byteLength)}

      `,1):n===x?`
`:""}
    `)}if(s.length>0&&e.reporter.info(ge`
      Also ${s.length} declaration ${l?"files are":"file is"} generated

      ${e.verbose?`  \u{1F4E6} ${s.map(n=>E(e.resolveRelativePath(n.path,!0))).join(`
  \u{1F4E6} `)}
`:""}
    `),o.length>0){for(let n of o)e.reporter.info(ge`
        Copied ${E(e.resolveRelativePath(n.sourcePath,!0))} to ${E(e.resolveRelativePath(n.path,!0))}
      `);console.log()}}var vt=Zt({tsTypes:{},schema:{events:{},context:{}},predictableActionArguments:!0,id:"buildMachine",initial:"bootstrap",states:{bootstrap:{on:{BUILD:{target:"buildEntries",actions:"reportBuildStart"},CLEAN:"cleanupFirst"}},buildEntries:{states:{buildBundleEntries:{initial:"build",states:{build:{invoke:{src:"buildBundleTask",onDone:[{target:"success",actions:"assignBundleOutputs"}],onError:[{target:"failure",actions:"assignBuildBundleError"}]}},success:{type:"final"},failure:{type:"final"}}},buildFileEntries:{initial:"build",states:{build:{invoke:{src:"buildFileTask",onDone:[{target:"success",actions:"assignFileOutputs"}],onError:[{target:"failure",actions:"assignBuildFileError"}]}},success:{type:"final"},failure:{type:"final"}}},buildTypeEntries:{initial:"build",states:{build:{invoke:{src:"buildTypeTask",onDone:[{target:"success",actions:"assignTypeOutputs"}],onError:[{target:"failure",actions:"assignBuildTypeError"}]}},success:{type:"final"},failure:{type:"final"}}}},type:"parallel",onDone:[{target:"cleanup",cond:"hasBuildErrors",actions:"reportBuildErrors"},{target:"emitEntries"}]},emitEntries:{invoke:{src:"emitTask",onDone:[{target:"reportEmitResults"}],onError:[{target:"cleanup",actions:"assignEmitError"}]}},done:{entry:"reportBuildEnd",type:"final"},cleanup:{invoke:{src:"cleanupTask",onDone:[{target:"done"}],onError:[{target:"done"}]}},chmodBinEntries:{invoke:{src:"chmodBinTask",onDone:[{target:"done"}],onError:[{target:"done"}]}},reportEmitResults:{invoke:{src:"reportEmitResults",onDone:[{target:"chmodBinEntries",cond:"hasBinEntries"},{target:"done"}]}},cleanupFirst:{invoke:{src:"cleanupTask",onDone:"bootstrap",onError:"bootstrap"},entry:"reportCleanupStart",exit:"reportCleanupEnd"}}},{guards:{hasBuildErrors:e=>Object.values(e.errors).some(Boolean),hasBinEntries:e=>e.entries.some(t=>t.key.startsWith("bin"))},actions:{reportBuildStart:Z({buildStartedAt:e=>wt.now()}),reportBuildEnd:e=>{if(Object.values(e.errors).some(Boolean))return;let s=(wt.now()-e.buildStartedAt).toFixed(1);e.root.reporter.info(`\u26A1 Done in ${s}ms.`)},reportCleanupStart:e=>{e.root.reporter.info(Qt`
          Cleanup outputs first

        `)},reportCleanupEnd:e=>{console.log()},reportBuildErrors:e=>{if(e.errors.buildBundle){e.root.reporter.error(e.errors.buildBundle.message);for(let t of e.errors.buildBundle.esbuildErrors)e.root.reporter.error(t.text)}if(e.errors.buildFile)for(let t of e.errors.buildFile.reasons)e.root.reporter.captureException(t);e.errors.buildType&&e.root.reporter.captureException(e.errors.buildType)},assignBundleOutputs:Z({bundleOutputs:(e,t)=>[...e.bundleOutputs,...t.data.outputFiles]}),assignFileOutputs:Z({bundleOutputs:(e,t)=>[...e.fileOutputs,...t.data.outputFiles]}),assignTypeOutputs:Z({typeOutputs:(e,t)=>[...e.typeOutputs,...t.data.outputFiles]}),assignBuildBundleError:Z({errors:(e,t)=>({...e.errors,buildBundle:t.data})}),assignBuildFileError:Z({errors:(e,t)=>({...e.errors,buildFile:t.data})}),assignBuildTypeError:Z((e,t)=>({errors:{...e.errors,buildType:t.data}})),assignEmitError:Z({errors:(e,t)=>({...e.errors,emit:t.data})})},services:{buildBundleTask:e=>gt({context:e.root,bundleEntries:e.entries.filter(Ne)}),buildFileTask:e=>ht({context:e.root,fileEntries:e.entries.filter(at)}),buildTypeTask:e=>Et({context:e.root,typeEntries:e.entries.filter(it)}),emitTask:e=>$t({context:e.root,outputFiles:[...e.bundleOutputs,...e.fileOutputs,...e.typeOutputs]}),reportEmitResults:e=>Tt({context:e.root,bundleOutputs:e.bundleOutputs,fileOutputs:e.fileOutputs,typeOutputs:e.typeOutputs}),cleanupTask:e=>ve({context:e.root,outputFiles:e.entries.map(t=>({sourcePath:t.sourceFile[0],path:t.outputFile}))}),chmodBinTask:e=>kt({context:e.root,binEntries:e.entries.filter(Ne).filter(t=>t.key.startsWith("bin"))})}});async function Ft({context:e,entries:t,cleanFirst:o=!1}){e.reporter.info(er`
    Build ${xe(e.manifest.name||"unnamed")} package

  `);let s=rr(vt.withContext({root:e,entries:t,bundleOutputs:[],fileOutputs:[],typeOutputs:[],errors:{},buildStartedAt:tr.now()}));return s.start(),o?(s.send("CLEAN"),s.onTransition(r=>{r.can("BUILD")&&s.send("BUILD")})):s.send("BUILD"),new Promise((r,x)=>{s.onDone(()=>{let l=s.getSnapshot();Object.values(l.context.errors).some(Boolean)?x(new B):r()})})}import or from"string-dedent";async function Ct({context:e,entries:t}){e.reporter.info(or`
    Clean ${xe(e.manifest.name||"unnamed")} package

  `);let o=t.map(s=>({sourcePath:s.sourceFile[0],path:s.outputFile}));await ve({context:e,outputFiles:o})}var{flags:be,input:nr}=Ue,[he]=nr,G=new ie(console);G.level=process.env.DEBUG==="true"?"debug":"default";he||Ue.showHelp(0);var ir=["build","clean"];try{if(ir.includes(he)){let e=await tt({basePath:be.cwd});G.debug("loaded manifest %o",e);let t=await sr(be.tsconfig,{resolveWithEmptyIfConfigNotFound:!0}),o=t.tsconfigFile!=="no_tsconfig_file_found"?t.tsconfigFile:void 0;o&&G.debug(`loaded tsconfig from ${o}`);let s=t.tsconfigFile!=="no_tsconfig_file_found"?t.tsconfig:void 0;s&&G.debug("loaded tsconfig %o",s);let r=await Qe({basePath:be.cwd});G.debug(`loaded targets ${r.join(", ")}`);let x=ot({flags:be,targets:r,manifest:e,tsconfig:s,tsconfigPath:o,reporter:G});G.debug("loaded context %o",x);let l=nt({context:x,reporter:G});if(l.some(n=>n.module==="dts")&&o==null)throw new fe(Bt`
        You have set ${y("types")} entry. But no ${E("tsconfig.json")} found.

          Please create ${E("tsconfig.json")} file in the current directory, or pass its path to ${Y("--tsconfig")} argument.

      `);G.debug("parsed entries %o",l),he==="build"&&await Ft({context:x,entries:l,cleanFirst:be.clean}),he==="clean"&&await Ct({context:x,entries:l})}else throw new B(Bt`
      Command "${he}" is not available.

        Run ${Y("nanobundle --help")} for usage.
    `)}catch(e){e instanceof B?e.message&&G.error(e.message):G.captureException(e),process.exit(1)}
