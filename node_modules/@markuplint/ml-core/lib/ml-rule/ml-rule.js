var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _MLRule_f, _MLRule_v;
import { deleteUndefProp } from '@markuplint/ml-config';
// @ts-ignore
import { isPlainObject } from 'is-plain-object';
import { MLRuleContext } from './ml-rule-context.js';
export class MLRule {
    constructor(o) {
        _MLRule_f.set(this, void 0);
        _MLRule_v.set(this, void 0);
        this.name = o.name;
        this.defaultSeverity = o.defaultSeverity ?? 'error';
        // TODO: https://github.com/markuplint/markuplint/issues/808
        this.defaultValue = (o.defaultValue === undefined ? true : o.defaultValue);
        this.defaultOptions = o.defaultOptions;
        __classPrivateFieldSet(this, _MLRule_v, o.verify, "f");
        __classPrivateFieldSet(this, _MLRule_f, o.fix, "f");
    }
    /**
     * The following getter is unused internally,
     * only for extending from 3rd party library
     */
    get f() {
        return __classPrivateFieldGet(this, _MLRule_f, "f");
    }
    /**
     * The following getter is unused internally,
     * only for extending from 3rd party library
     */
    get v() {
        return __classPrivateFieldGet(this, _MLRule_v, "f");
    }
    getRuleInfo(ruleSet, ruleName) {
        const info = this._optimize(ruleSet.rules, ruleName);
        return {
            ...info,
            nodeRules: ruleSet.nodeRules.map(r => this._optimize(r.rules, ruleName)).filter(r => !r.disabled),
            childNodeRules: ruleSet.childNodeRules.map(r => this._optimize(r.rules, ruleName)).filter(r => !r.disabled),
        };
    }
    optimizeOption(configSettings) {
        if (configSettings === undefined || typeof configSettings === 'boolean') {
            return {
                disabled: !configSettings,
                severity: this.defaultSeverity,
                value: this.defaultValue,
                options: this.defaultOptions,
                reason: undefined,
            };
        }
        if (isRuleConfig(configSettings)) {
            return {
                disabled: false,
                severity: configSettings.severity ?? this.defaultSeverity,
                value: configSettings.value === undefined ||
                    // @ts-ignore
                    configSettings.value === true
                    ? this.defaultValue
                    : configSettings.value,
                options: mergeOptions(this.defaultOptions, configSettings.options),
                reason: configSettings.reason,
            };
        }
        return {
            disabled: false,
            severity: this.defaultSeverity,
            value: configSettings == null ? this.defaultValue : configSettings,
            options: this.defaultOptions,
            reason: undefined,
        };
    }
    async verify(
    // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
    document, locale, fix) {
        document.setRule(this);
        const context = new MLRuleContext(document, locale);
        const providableContext = context.provide();
        await __classPrivateFieldGet(this, _MLRule_v, "f").call(this, providableContext);
        if (__classPrivateFieldGet(this, _MLRule_f, "f") && fix) {
            await __classPrivateFieldGet(this, _MLRule_f, "f").call(this, providableContext);
        }
        const violation = context.reports.map(report => {
            if ('scope' in report) {
                let line = report.scope.startLine;
                let col = report.scope.startCol;
                let raw = report.scope.raw;
                if ('line' in report && report.line != null) {
                    line = report.line;
                    col = report.col;
                    raw = report.raw;
                }
                const violation = {
                    severity: report.scope.rule.severity,
                    message: report.message,
                    line,
                    col,
                    raw,
                    ruleId: this.name,
                    reason: report.scope.rule.reason ?? document.rule.reason,
                };
                deleteUndefProp(violation);
                return violation;
            }
            const violation = {
                severity: document.rule.severity,
                message: report.message,
                line: report.line,
                col: report.col,
                raw: report.raw,
                ruleId: this.name,
                reason: document.rule.reason,
            };
            deleteUndefProp(violation);
            return violation;
        });
        document.setRule(null);
        return violation;
    }
    _optimize(rules, ruleName) {
        const rule = (rules?.[ruleName] ?? false);
        const info = this.optimizeOption(rule);
        return info;
    }
}
_MLRule_f = new WeakMap(), _MLRule_v = new WeakMap();
function isRuleConfig(data) {
    return isPlainObject(data);
}
function mergeOptions(a, b) {
    if (Array.isArray(a) && Array.isArray(b)) {
        // @ts-ignore
        return [...a, ...b];
    }
    if (isPlainObject(a) && isPlainObject(b)) {
        // @ts-ignore
        return { ...a, ...b };
    }
    return b ?? a;
}
