var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _MLDOMIndentation_fixed, _MLDOMIndentation_node, _MLDOMIndentation_parent;
/**
 *
 * @deprecated
 * @param node
 */
export function getIndent(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
node) {
    const prevToken = node.prevToken;
    if (!prevToken) {
        return null;
    }
    if (node.is(node.TEXT_NODE)) {
        if (node.isRawTextElementContent()) {
            return null;
        }
        const matched = node.raw.match(/^([\t\v\f\r \u00A0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*\n\s*)\S+/);
        if (matched) {
            const spaces = matched[1];
            if (spaces) {
                const spaceLines = spaces.split(/\r?\n/);
                const line = spaceLines.length + node.startLine - 1;
                const lastSpace = spaceLines.pop();
                if (lastSpace != null) {
                    return new MLDOMIndentation(node, lastSpace, line, node);
                }
            }
        }
        return null;
    }
    if (!prevToken.is(node.TEXT_NODE)) {
        return null;
    }
    // One or more newlines and zero or more spaces or tabs.
    // Or, If textNode is first token and that is filled spaces, tabs and newlines only.
    const matched = isFirstToken(prevToken)
        ? prevToken.raw.match(/^(?:[\t ]*\r?\n)*([\t ]*)$/)
        : prevToken.raw.match(/\r?\n([\t ]*)$/);
    // console.log({ [`${this}`]: matched, _: prevToken.raw, f: prevToken._isFirstToken() });
    if (matched) {
        // Spaces will include empty string.
        const spaces = matched[1];
        if (spaces != null) {
            return new MLDOMIndentation(prevToken, spaces, node.startLine, node);
        }
    }
    return null;
}
class MLDOMIndentation {
    constructor(
    // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
    originTextNode, raw, line, 
    // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
    parentNode) {
        _MLDOMIndentation_fixed.set(this, void 0);
        _MLDOMIndentation_node.set(this, void 0);
        _MLDOMIndentation_parent.set(this, void 0);
        this.line = line;
        __classPrivateFieldSet(this, _MLDOMIndentation_node, originTextNode, "f");
        __classPrivateFieldSet(this, _MLDOMIndentation_parent, parentNode, "f");
        __classPrivateFieldSet(this, _MLDOMIndentation_fixed, raw, "f");
    }
    get raw() {
        if (!__classPrivateFieldGet(this, _MLDOMIndentation_parent, "f").is(__classPrivateFieldGet(this, _MLDOMIndentation_parent, "f").TEXT_NODE) && this.line !== __classPrivateFieldGet(this, _MLDOMIndentation_node, "f").endLine) {
            return '';
        }
        return __classPrivateFieldGet(this, _MLDOMIndentation_fixed, "f");
    }
    get type() {
        if (!__classPrivateFieldGet(this, _MLDOMIndentation_parent, "f").is(__classPrivateFieldGet(this, _MLDOMIndentation_parent, "f").TEXT_NODE) && this.line !== __classPrivateFieldGet(this, _MLDOMIndentation_node, "f").endLine) {
            return 'none';
        }
        const raw = __classPrivateFieldGet(this, _MLDOMIndentation_fixed, "f");
        return raw === '' ? 'none' : /^\t+$/.test(raw) ? 'tab' : /^[^\t]+$/.test(raw) ? 'space' : 'mixed';
    }
    get width() {
        if (!__classPrivateFieldGet(this, _MLDOMIndentation_parent, "f").is(__classPrivateFieldGet(this, _MLDOMIndentation_parent, "f").TEXT_NODE) && this.line !== __classPrivateFieldGet(this, _MLDOMIndentation_node, "f").endLine) {
            return 0;
        }
        return __classPrivateFieldGet(this, _MLDOMIndentation_fixed, "f").length;
    }
    fix(raw) {
        const current = __classPrivateFieldGet(this, _MLDOMIndentation_fixed, "f");
        __classPrivateFieldSet(this, _MLDOMIndentation_fixed, raw, "f");
        const node = __classPrivateFieldGet(this, _MLDOMIndentation_node, "f");
        const line = node.startLine;
        const lines = node.raw.split(/\r?\n/);
        const index = this.line - line;
        if (lines[index] != null) {
            lines[index] = lines[index].replace(current, __classPrivateFieldGet(this, _MLDOMIndentation_fixed, "f"));
        }
        node.fix(lines.join('\n'));
    }
}
_MLDOMIndentation_fixed = new WeakMap(), _MLDOMIndentation_node = new WeakMap(), _MLDOMIndentation_parent = new WeakMap();
function isFirstToken(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
node) {
    return !node.prevToken;
}
