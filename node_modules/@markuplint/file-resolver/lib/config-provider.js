var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ConfigProvider_cache, _ConfigProvider_held, _ConfigProvider_recursiveLoadKeyAndDepth, _ConfigProvider_store;
import path from 'node:path';
import { mergeConfig } from '@markuplint/ml-config';
import { ConfigParserError } from '@markuplint/parser-utils';
import { InvalidSelectorError, createSelector } from '@markuplint/selector';
import { nonNullableFilter, toNoEmptyStringArrayFromStringOrArray } from '@markuplint/shared';
import { ConfigLoadError } from './config-load-error.js';
import { load as loadConfig, search } from './cosmiconfig.js';
import { log } from './debug.js';
import { generalImport } from './general-import.js';
import { getPreset } from './get-preset.js';
import { isPluginModuleName } from './is-plugin-module-name.js';
import { isPresetModuleName } from './is-preset-module-name.js';
import { moduleExists } from './module-exists.js';
import { relPathToNameOrAbsPath } from './path-to-abs-or-name.js';
import { cacheClear, resolvePlugins } from './resolve-plugins.js';
import { fileExists, uuid } from './utils.js';
const cpLog = log.extend('config-provider');
const KEY_SEPARATOR = '__ML_CONFIG_MERGE__';
export class ConfigProvider {
    constructor() {
        _ConfigProvider_cache.set(this, new Map());
        _ConfigProvider_held.set(this, new Set());
        _ConfigProvider_recursiveLoadKeyAndDepth.set(this, new Map());
        _ConfigProvider_store.set(this, new Map());
    }
    async recursiveLoad(key, cache, referrer, depth = 1) {
        const stack = new Set();
        const errs = [];
        const ancestorDepth = __classPrivateFieldGet(this, _ConfigProvider_recursiveLoadKeyAndDepth, "f").get(key);
        if (ancestorDepth != null && ancestorDepth < depth) {
            return {
                stack,
                errs: [new CircularReferenceError(`Circular reference detected: ${key}`)],
            };
        }
        __classPrivateFieldGet(this, _ConfigProvider_recursiveLoadKeyAndDepth, "f").set(key, depth);
        let config = __classPrivateFieldGet(this, _ConfigProvider_store, "f").get(key);
        if (!config) {
            config = await this._load(key, cache, referrer);
        }
        if (!config) {
            return { stack, errs: [] };
        }
        if (config instanceof ConfigLoadError) {
            stack.add(config.filePath);
            return {
                stack,
                errs: [config],
            };
        }
        const depKeys = config.extends === null ? null : toNoEmptyStringArrayFromStringOrArray(config.extends);
        if (depKeys) {
            for (const depKey of depKeys) {
                const keys = await this.recursiveLoad(depKey, cache, key, depth + 1);
                for (const key of keys.stack) {
                    stack.add(key);
                }
                errs.push(...keys.errs);
            }
        }
        stack.add(key);
        return { stack, errs };
    }
    async resolve(targetFile, names, cache = true) {
        if (!cache) {
            __classPrivateFieldGet(this, _ConfigProvider_store, "f").clear();
            __classPrivateFieldGet(this, _ConfigProvider_cache, "f").clear();
            cacheClear();
        }
        const keys = names.filter(nonNullableFilter);
        const key = keys.join(KEY_SEPARATOR);
        const currentConfig = __classPrivateFieldGet(this, _ConfigProvider_cache, "f").get(key);
        if (currentConfig) {
            return currentConfig;
        }
        let configSet = await this._mergeConfigs(keys, cache, targetFile.path);
        const filePath = [...configSet.files].reverse()[0];
        if (!filePath) {
            throw new ConfigParserError('Config file not found', {
                filePath: targetFile.path,
            });
        }
        const errors = this._validateConfig(configSet.config, filePath);
        configSet.errs.push(...errors);
        const plugins = await resolvePlugins(configSet.config.plugins);
        if (__classPrivateFieldGet(this, _ConfigProvider_held, "f").size > 0) {
            const extendHelds = [...__classPrivateFieldGet(this, _ConfigProvider_held, "f").values()];
            for (const held of extendHelds) {
                const [, prefix, namespace, name] = held.match(/^([a-z]+:)([^/]+)(?:\/(.+))?$/) ?? [];
                switch (prefix) {
                    case 'plugin:': {
                        const plugin = plugins.find(plugin => plugin.name === namespace);
                        const config = plugin?.configs?.[name ?? ''];
                        if (config) {
                            this.set(config, held);
                        }
                        break;
                    }
                }
            }
            configSet = await this._mergeConfigs([...keys, ...extendHelds], cache, targetFile.path);
            __classPrivateFieldGet(this, _ConfigProvider_held, "f").clear();
        }
        // Resolves `overrides`
        if (configSet.config.overrides) {
            const overrides = configSet.config.overrides;
            const globs = Object.keys(overrides);
            for (const glob of globs) {
                const isMatched = targetFile.matches(glob);
                const config = overrides[glob];
                if (isMatched && config) {
                    // Note: Original config disappears
                    configSet.config = config;
                }
            }
        }
        const result = {
            ...configSet,
            plugins,
        };
        __classPrivateFieldGet(this, _ConfigProvider_cache, "f").set(key, result);
        return result;
    }
    async search(targetFile) {
        const isExists = await targetFile.dirExists();
        cpLog('search: %s', targetFile.path);
        cpLog('isExists: %s', isExists);
        if (!isExists) {
            return null;
        }
        const res = await search(targetFile.path, false);
        cpLog('searched config: %O', res);
        if (!res) {
            return null;
        }
        const { filePath, config } = res;
        const pathResolvedConfig = await this._pathResolve(config, filePath);
        __classPrivateFieldGet(this, _ConfigProvider_store, "f").set(filePath, pathResolvedConfig);
        cpLog('Store key: %s', filePath);
        return filePath;
    }
    set(config, key) {
        key = key ?? uuid();
        __classPrivateFieldGet(this, _ConfigProvider_store, "f").set(key, config);
        return key;
    }
    async _load(filePath, cache, referrer) {
        const entity = __classPrivateFieldGet(this, _ConfigProvider_store, "f").get(filePath);
        if (entity) {
            return entity;
        }
        if (isPresetModuleName(filePath)) {
            const [, name] = filePath.match(/^markuplint:(.+)$/i) ?? [];
            const config = await getPreset(name ?? filePath);
            const pathResolvedConfig = await this._pathResolve(config, filePath);
            __classPrivateFieldGet(this, _ConfigProvider_store, "f").set(filePath, pathResolvedConfig);
            return pathResolvedConfig;
        }
        if (isPluginModuleName(filePath)) {
            __classPrivateFieldGet(this, _ConfigProvider_held, "f").add(filePath);
            return;
        }
        if (!(await moduleExists(filePath)) && !path.isAbsolute(filePath)) {
            throw new TypeError(`${filePath} is not an absolute path`);
        }
        const config = await load(filePath, cache, referrer);
        if (config instanceof ConfigLoadError) {
            return config;
        }
        const pathResolvedConfig = await this._pathResolve(config, filePath);
        __classPrivateFieldGet(this, _ConfigProvider_store, "f").set(filePath, pathResolvedConfig);
        return pathResolvedConfig;
    }
    async _mergeConfigs(keys, cache, referrer) {
        const resolvedKeys = new Set();
        const errs = [];
        for (const key of keys) {
            __classPrivateFieldGet(this, _ConfigProvider_recursiveLoadKeyAndDepth, "f").clear();
            const keySet = await this.recursiveLoad(key, cache, referrer);
            for (const k of keySet.stack) {
                resolvedKeys.add(k);
            }
            errs.push(...keySet.errs);
        }
        const configs = [...resolvedKeys].map(name => __classPrivateFieldGet(this, _ConfigProvider_store, "f").get(name)).filter(nonNullableFilter);
        let resultConfig = {};
        for (const config of configs) {
            if (config instanceof ConfigLoadError) {
                errs.push(config);
                continue;
            }
            resultConfig = mergeConfig(resultConfig, config);
        }
        return {
            config: resultConfig,
            files: resolvedKeys,
            errs,
        };
    }
    async _pathResolve(config, filePath) {
        const dir = path.dirname(filePath);
        return {
            ...config,
            extends: await relPathToNameOrAbsPath(dir, config.extends),
            plugins: await relPathToNameOrAbsPath(dir, config.plugins, ['name']),
            parser: await relPathToNameOrAbsPath(dir, config.parser),
            specs: await relPathToNameOrAbsPath(dir, config.specs),
            excludeFiles: await relPathToNameOrAbsPath(dir, config.excludeFiles),
            overrides: await relPathToNameOrAbsPath(dir, config.overrides, undefined, true),
        };
    }
    _validateConfig(config, filePath) {
        const errors = [];
        if (config.nodeRules)
            for (const rule of config.nodeRules) {
                if (rule.selector) {
                    try {
                        createSelector(rule.selector);
                    }
                    catch (error) {
                        if (error instanceof InvalidSelectorError) {
                            errors.push(new ConfigParserError(error.message, {
                                filePath,
                                raw: rule.selector,
                            }));
                        }
                    }
                }
            }
        return errors;
    }
}
_ConfigProvider_cache = new WeakMap(), _ConfigProvider_held = new WeakMap(), _ConfigProvider_recursiveLoadKeyAndDepth = new WeakMap(), _ConfigProvider_store = new WeakMap();
async function load(filePath, cache, referrer) {
    if (!fileExists(filePath) && (await moduleExists(filePath))) {
        const config = (await generalImport(filePath)) ?? new ConfigLoadError('Module is not found', filePath, referrer);
        return config;
    }
    const res = await loadConfig(filePath, !cache, referrer).catch((error) => {
        if (error instanceof ConfigLoadError) {
            return error;
        }
        throw error;
    });
    if (res instanceof ConfigLoadError) {
        return res;
    }
    return res.config;
}
class CircularReferenceError extends ReferenceError {
    constructor() {
        super(...arguments);
        this.name = 'CircularReferenceError';
    }
}
