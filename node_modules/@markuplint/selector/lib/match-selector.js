var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SelectorTarget_combinedFrom, _SelectorTarget_selector;
import { isElement, isNonDocumentTypeChildNode, isPureHTMLElement } from './is.js';
import { regexSelectorMatches } from './regex-selector-matches.js';
import { Selector } from './selector.js';
export function matchSelector(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
el, selector) {
    if (selector == null || selector === '') {
        return {
            matched: false,
        };
    }
    if (typeof selector === 'string') {
        const sel = new Selector(selector);
        const specificity = sel.match(el);
        if (specificity !== false) {
            return {
                matched: true,
                selector,
                specificity,
            };
        }
        return {
            matched: false,
        };
    }
    return regexSelect(el, selector);
}
function regexSelect(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
el, selector) {
    let edge = new SelectorTarget(selector);
    let edgeSelector = selector.combination;
    while (edgeSelector) {
        const child = new SelectorTarget(edgeSelector);
        child.from(edge, edgeSelector.combinator);
        edge = child;
        edgeSelector = edgeSelector.combination;
    }
    return edge.match(el);
}
class SelectorTarget {
    constructor(selector) {
        _SelectorTarget_combinedFrom.set(this, null);
        _SelectorTarget_selector.set(this, void 0);
        __classPrivateFieldSet(this, _SelectorTarget_selector, selector, "f");
    }
    from(target, combinator) {
        __classPrivateFieldSet(this, _SelectorTarget_combinedFrom, { target, combinator }, "f");
    }
    match(
    // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
    el) {
        const unitCheck = this._matchWithoutCombineChecking(el);
        if (!unitCheck.matched) {
            return unitCheck;
        }
        if (!__classPrivateFieldGet(this, _SelectorTarget_combinedFrom, "f")) {
            return unitCheck;
        }
        if (!isNonDocumentTypeChildNode(el)) {
            return unitCheck;
        }
        const { target, combinator } = __classPrivateFieldGet(this, _SelectorTarget_combinedFrom, "f");
        switch (combinator) {
            // Descendant combinator
            case ' ': {
                let ancestor = el.parentElement;
                while (ancestor) {
                    const matches = target.match(ancestor);
                    if (matches.matched) {
                        return mergeMatches(matches, unitCheck, ' ');
                    }
                    ancestor = ancestor.parentElement;
                }
                return {
                    matched: false,
                };
            }
            // Child combinator
            case '>': {
                const parentNode = el.parentElement;
                if (!parentNode) {
                    return { matched: false };
                }
                const matches = target.match(parentNode);
                if (matches.matched) {
                    return mergeMatches(matches, unitCheck, ' > ');
                }
                return { matched: false };
            }
            // Next-sibling combinator
            case '+': {
                if (!el.previousElementSibling) {
                    return { matched: false };
                }
                const matches = target.match(el.previousElementSibling);
                if (matches.matched) {
                    return mergeMatches(matches, unitCheck, ' + ');
                }
                return { matched: false };
            }
            // Subsequent-sibling combinator
            case '~': {
                let prev = el.previousElementSibling;
                while (prev) {
                    const matches = target.match(prev);
                    if (matches.matched) {
                        return mergeMatches(matches, unitCheck, ' ~ ');
                    }
                    prev = prev.previousElementSibling;
                }
                return { matched: false };
            }
            // Prev-sibling combinator
            case ':has(+)': {
                if (!el.nextElementSibling) {
                    return { matched: false };
                }
                const matches = target.match(el.nextElementSibling);
                if (matches.matched) {
                    return mergeMatches(matches, unitCheck, ':has(+ ', true);
                }
                return { matched: false };
            }
            // Subsequent-sibling (in front) combinator
            case ':has(~)': {
                let next = el.nextElementSibling;
                while (next) {
                    const matches = target.match(next);
                    if (matches.matched) {
                        return mergeMatches(matches, unitCheck, ':has(~ ', true);
                    }
                    next = next.nextElementSibling;
                }
                return { matched: false };
            }
            default: {
                throw new Error(`Unsupported ${__classPrivateFieldGet(this, _SelectorTarget_combinedFrom, "f").combinator} combinator in selector`);
            }
        }
    }
    _matchWithoutCombineChecking(
    // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
    el) {
        return uncombinedRegexSelect(el, __classPrivateFieldGet(this, _SelectorTarget_selector, "f"));
    }
}
_SelectorTarget_combinedFrom = new WeakMap(), _SelectorTarget_selector = new WeakMap();
function uncombinedRegexSelect(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
el, selector) {
    if (!isElement(el)) {
        return {
            matched: false,
        };
    }
    let matched = true;
    let data = {};
    let tagSelector = '';
    const specificity = [0, 0, 0];
    const specifiedAttr = new Map();
    if (selector.nodeName) {
        const matchedNodeName = regexSelectorMatches(selector.nodeName, el.localName, isPureHTMLElement(el));
        if (matchedNodeName) {
            delete matchedNodeName.$0;
        }
        else {
            matched = false;
        }
        data = {
            ...data,
            ...matchedNodeName,
        };
        tagSelector = el.localName;
        specificity[2] = 1;
    }
    const isPure = isPureHTMLElement(el);
    if (selector.attrName || selector.attrValue) {
        const matchedAttrList = [...el.attributes]
            .map(attr => {
            const matchedAttrName = regexSelectorMatches(selector.attrName, attr.name, isPure);
            if (selector.attrName && !matchedAttrName) {
                return null;
            }
            const matchedAttrValue = regexSelectorMatches(selector.attrValue, attr.value, isPure);
            if (selector.attrValue && !matchedAttrValue) {
                return null;
            }
            if (matchedAttrName) {
                delete matchedAttrName.$0;
            }
            if (matchedAttrValue) {
                delete matchedAttrValue.$0;
            }
            data = {
                ...data,
                ...matchedAttrName,
                ...matchedAttrValue,
            };
            specifiedAttr.set(attr.name, matchedAttrValue ? attr.value : '');
            return matchedAttrValue ?? matchedAttrName ?? null;
        })
            .filter((a) => !!a);
        if (matchedAttrList.length === 0) {
            matched = false;
        }
    }
    const attrSelector = [...specifiedAttr.entries()]
        .map(([name, value]) => {
        return `[${name}${value ? `="${value}"` : ''}]`;
    })
        .join('');
    specificity[1] += specifiedAttr.size;
    if (matched) {
        return {
            matched,
            selector: `${tagSelector}${attrSelector}`,
            specificity,
            data,
        };
    }
    return { matched };
}
function mergeMatches(a, b, sep, close = false) {
    return {
        matched: true,
        selector: `${a.selector}${sep}${b.selector}${close ? ')' : ''}`,
        specificity: [
            a.specificity[0] + b.specificity[0],
            a.specificity[1] + b.specificity[1],
            a.specificity[2] + b.specificity[2],
        ],
        data: {
            ...a.data,
            ...b.data,
        },
    };
}
