var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Collection_locked, _Collection_matched, _Collection_nodes, _Collection_origin;
import { createSelector } from '@markuplint/selector';
import { bgGreen, green, bgRed, bgBlue, blue, bgMagenta, cyan } from './debug.js';
import { transparentMode } from './represent-transparent-nodes.js';
const getChildNodesWithoutWhitespacesCaches = new Map();
export function getChildNodesWithoutWhitespaces(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
el) {
    let nodes = getChildNodesWithoutWhitespacesCaches.get(el);
    if (nodes) {
        return nodes;
    }
    nodes = [...el.childNodes].filter(node => {
        return !(node.is(node.TEXT_NODE) && node.isWhitespace());
    });
    getChildNodesWithoutWhitespacesCaches.set(el, nodes);
    return nodes;
}
export function isModel(model) {
    if (typeof model === 'string') {
        return true;
    }
    let modelMode = false;
    for (const m of model) {
        if (typeof m === 'string') {
            modelMode = true;
            continue;
        }
        if (modelMode) {
            throw new TypeError(`Invalid schema: ${JSON.stringify(model)}`);
        }
    }
    return modelMode;
}
export function matches(selector, 
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
node, specs) {
    const selectorResult = createSelector(selector, specs).search(node);
    const matched = selectorResult.filter((r) => r.matched);
    if (matched.length > 0) {
        return {
            matched: true,
        };
    }
    const not = selectorResult
        .flatMap(r => (r.matched ? [] : r.not ?? []))
        .flatMap(descendants)
        .shift();
    return {
        matched: false,
        not,
    };
}
function descendants(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
selectorResult) {
    let nodes = [...selectorResult.nodes];
    while (selectorResult.has.length > 0) {
        for (const dep of selectorResult.has) {
            if (dep.has.length === 0) {
                nodes = dep.nodes;
                continue;
            }
            selectorResult = dep;
            continue;
        }
        break;
    }
    return nodes;
}
export function isRequire(content) {
    return 'require' in content;
}
export function isOptional(content) {
    return 'optional' in content;
}
export function isOneOrMore(content) {
    return 'oneOrMore' in content;
}
export function isZeroOrMore(content) {
    return 'zeroOrMore' in content;
}
export function isChoice(content) {
    return 'choice' in content;
}
export function isTransparent(content) {
    return 'transparent' in content;
}
export function normalizeModel(pattern) {
    let model;
    let min;
    let max;
    let repeat;
    let missingType;
    if (isRequire(pattern)) {
        model = pattern.require;
        min = pattern.min ?? 1;
        max = Math.max(pattern.max ?? 1, min);
        missingType = 'MISSING_NODE_REQUIRED';
    }
    else if (isOptional(pattern)) {
        model = pattern.optional;
        min = 0;
        max = Math.max(pattern.max ?? 1, 1);
    }
    else if (isOneOrMore(pattern)) {
        model = pattern.oneOrMore;
        min = 1;
        max = Math.max(pattern.max ?? Number.POSITIVE_INFINITY, 1);
        missingType = 'MISSING_NODE_ONE_OR_MORE';
    }
    else if (isZeroOrMore(pattern)) {
        model = pattern.zeroOrMore;
        min = 0;
        max = Math.max(pattern.max ?? Number.POSITIVE_INFINITY, 1);
    }
    else {
        throw new Error('Unreachable code');
    }
    if (min === 0 && max === 1) {
        repeat = '?';
    }
    else if (min === 0 && !Number.isFinite(max)) {
        repeat = '*';
    }
    else if (min === 1 && max === 1) {
        repeat = '';
    }
    else if (min === 1 && !Number.isFinite(max)) {
        repeat = '+';
    }
    else {
        repeat = `{${min},${max}}`;
    }
    return {
        model,
        min,
        max,
        repeat,
        missingType,
    };
}
export function mergeHints(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
a, 
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
b) {
    const missing = [a.missing, b.missing].sort((a, b) => (b?.barelyMatchedElements ?? 0) - (a?.barelyMatchedElements ?? 0))[0];
    return cleanObject({
        ...a,
        ...b,
        missing: missing && cleanObject(missing),
    });
}
export function cleanObject(object) {
    const newObject = {};
    for (const [key, value] of Object.entries(object)) {
        if (value !== undefined) {
            newObject[key] = value;
        }
    }
    return newObject;
}
export class Collection {
    constructor(
    // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
    origin) {
        _Collection_locked.set(this, new Set());
        _Collection_matched.set(this, new Set());
        _Collection_nodes.set(this, void 0);
        _Collection_origin.set(this, void 0);
        __classPrivateFieldSet(this, _Collection_origin, [...origin], "f");
        __classPrivateFieldSet(this, _Collection_nodes, new Set(__classPrivateFieldGet(this, _Collection_origin, "f")), "f");
    }
    get matched() {
        return [...__classPrivateFieldGet(this, _Collection_matched, "f")];
    }
    get matchedCount() {
        return __classPrivateFieldGet(this, _Collection_matched, "f").size;
    }
    get nodes() {
        return [...__classPrivateFieldGet(this, _Collection_origin, "f")];
    }
    get unmatched() {
        return [...__classPrivateFieldGet(this, _Collection_nodes, "f")].filter(n => !__classPrivateFieldGet(this, _Collection_matched, "f").has(n));
    }
    addMatched(
    // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
    nodes) {
        const i = __classPrivateFieldGet(this, _Collection_matched, "f").size;
        for (const node of nodes) {
            if (!__classPrivateFieldGet(this, _Collection_nodes, "f").has(node)) {
                throw new ReferenceError(`External Node: ${node.nodeName}`);
            }
            __classPrivateFieldGet(this, _Collection_matched, "f").add(node);
        }
        return i < __classPrivateFieldGet(this, _Collection_matched, "f").size;
    }
    back() {
        __classPrivateFieldSet(this, _Collection_matched, new Set(__classPrivateFieldGet(this, _Collection_locked, "f")), "f");
    }
    lock() {
        __classPrivateFieldSet(this, _Collection_locked, new Set(__classPrivateFieldGet(this, _Collection_matched, "f")), "f");
    }
    max(max) {
        const sliced = [...__classPrivateFieldGet(this, _Collection_matched, "f")].slice(max);
        for (const n of sliced)
            __classPrivateFieldGet(this, _Collection_matched, "f").delete(n);
    }
    toString(highlightExtraNodes = false) {
        const out = [];
        for (const n of __classPrivateFieldGet(this, _Collection_origin, "f")) {
            const raw = n.is(n.TEXT_NODE) ? `:text(${n.raw.replaceAll('\n', '\\n')})` : n.raw;
            if (__classPrivateFieldGet(this, _Collection_locked, "f").has(n)) {
                if (transparentMode.has(n)) {
                    out.push(bgBlue.bold(raw));
                }
                else {
                    out.push(bgGreen.bold(raw));
                }
                continue;
            }
            if (__classPrivateFieldGet(this, _Collection_matched, "f").has(n)) {
                if (transparentMode.has(n)) {
                    out.push(blue.bold(raw));
                }
                else {
                    out.push(green.bold(raw));
                }
                continue;
            }
            if (highlightExtraNodes) {
                if (transparentMode.has(n)) {
                    out.push(bgMagenta.bold(raw));
                }
                else {
                    out.push(bgRed.bold(raw));
                }
                continue;
            }
            if (transparentMode.has(n)) {
                out.push(cyan(raw));
            }
            else {
                out.push(raw);
            }
        }
        return `[ ${out.join(', ')} ]`;
    }
}
_Collection_locked = new WeakMap(), _Collection_matched = new WeakMap(), _Collection_nodes = new WeakMap(), _Collection_origin = new WeakMap();
export class UnsupportedError extends Error {
}
export function modelLog(model, repeat) {
    if (!isModel(model)) {
        return orderLog(model, repeat);
    }
    if (typeof model === 'string') {
        return `<${model}>${repeat}`;
    }
    return `(<${model.join('>|<')}>)${repeat}`;
}
function orderLog(order, repeat) {
    return order.length === 1 && order[0]
        ? markRepeat(patternLog(order[0]), repeat)
        : markRepeat(order.map(pattern => patternLog(pattern)).join(''), repeat);
}
function patternLog(pattern) {
    if (isTransparent(pattern)) {
        // 適当
        return `:transparent(${modelLog(pattern.transparent, '')})`;
    }
    if (isChoice(pattern)) {
        return `(${pattern.choice.map(candidate => orderLog(candidate, '')).join('|')})`;
    }
    const { model, repeat } = normalizeModel(pattern);
    return modelLog(model, repeat);
}
function markRepeat(pattern, repeat) {
    return repeat ? `(${pattern})${repeat}` : pattern;
}
