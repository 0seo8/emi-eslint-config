"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.taggedTemplateTranslator = exports.translator = void 0;
const defaultListFormat = {
    quoteStart: '"',
    quoteEnd: '"',
    separator: ', ',
};
function translator(localeSet) {
    return (messageTmpl, ...keywords) => {
        let message = messageTmpl;
        if (typeof messageTmpl !== 'string') {
            const format = localeSet?.listFormat ?? defaultListFormat;
            return `${format.quoteStart}${messageTmpl
                .map(keyword => translateKeyword(keyword, '', localeSet))
                .join(`${format.quoteEnd}${format.separator}${format.quoteStart}`)}${format.quoteEnd}`;
        }
        const input = messageTmpl;
        if (keywords.length === 0) {
            return translateKeyword(messageTmpl, '', localeSet);
        }
        const noTranslateIndex = new Set([
            ...messageTmpl.matchAll(
            // eslint-disable-next-line regexp/strict
            /(?<={)\d+(?=\*})/g),
        ].map(m => m[0]));
        const key = removeNoTranslateMark(messageTmpl).toLowerCase();
        const sentences = Object.entries(localeSet?.sentences ?? {});
        const sentence = sentences.find(([sentenceKey]) => sentenceKey.toLowerCase() === key)?.[1];
        messageTmpl = sentence ?? key;
        messageTmpl =
            removeNoTranslateMark(input.toLowerCase()) === messageTmpl ? removeNoTranslateMark(input) : messageTmpl;
        message = messageTmpl.replaceAll(
        // eslint-disable-next-line regexp/strict
        /{(\d+)(?::(c))?}/g, ($0, number, flag) => {
            const num = Number.parseInt(number);
            if (Number.isNaN(num)) {
                return $0;
            }
            const keyword = keywords[num] == null ? '' : toString(keywords[num], localeSet?.locale);
            // No translate
            if (noTranslateIndex.has(number)) {
                return keyword;
            }
            return translateKeyword(keyword, flag, localeSet);
        });
        return message;
    };
}
exports.translator = translator;
/**
 * @experimental
 */
function taggedTemplateTranslator(localeSet) {
    const t = translator(localeSet);
    return (strings, ...keys) => {
        let i = 0;
        const template = strings.raw
            .map((place, index) => {
            if (index === strings.raw.length - 1)
                return place;
            const value = keys[i];
            const cFlag = (typeof value === 'string' ? value : '').startsWith('c:') ? ':c' : '';
            return `${place}{${i++}${cFlag}}`;
        })
            .join('');
        return t(template, ...keys);
    };
}
exports.taggedTemplateTranslator = taggedTemplateTranslator;
function translateKeyword(keyword, flag, localeSet) {
    // No translate
    if (/^%[^%]+%$/.test(keyword)) {
        return keyword.replaceAll(/^%|%$/g, '');
    }
    // "%" prefix and suffix escaped
    keyword = keyword.replaceAll(/^%%|%%$/g, '%');
    const key = flag ? `${flag}:${keyword}` : keyword;
    const replacedWord = 
    // finding with flag
    localeSet?.keywords?.[key.toLowerCase()] ||
        // finding without flag
        localeSet?.keywords?.[keyword.toLowerCase()];
    return replacedWord || keyword;
}
function toString(value, locale = 'en') {
    switch (typeof value) {
        case 'string': {
            return value;
        }
        case 'number': {
            return toLocaleString(value, locale);
        }
        case 'boolean': {
            return `${value}`;
        }
    }
}
function toLocaleString(value, locale) {
    try {
        return value.toLocaleString(locale);
    }
    catch (error) {
        if (error instanceof RangeError) {
            try {
                return value.toLocaleString('en');
            }
            catch {
                // void
            }
        }
    }
    return value.toString(10);
}
function removeNoTranslateMark(message) {
    return message.replaceAll(
    // eslint-disable-next-line regexp/strict
    /(?<={\d+)\*(?=})/g, '');
}
